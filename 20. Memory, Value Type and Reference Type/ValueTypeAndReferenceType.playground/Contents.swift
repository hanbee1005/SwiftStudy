import UIKit

/*
 # Value Type vs Reference Type
 
 - Swift 에서 Stucture, Enumeration, Tuple 은 값 형식으로 분류하고, Class, Closure 는 참조 형식으로 분류합니다.
 */

struct SizeValue {
    var width = 0.0
    var height = 0.0
}

var value = SizeValue()

// 이렇게 인스턴스를 생성하면 stack 에 메모리 공간이 생성되고 여기에는 0.0으로 초기화된 값이 저장됩니다. 그리고 value 변수와 메모리 공간이 연결됩니다.

var value2 = value

// 이 경우 값 형식에서는 값이 복사됩니다. value 인스턴스의 복사본이 새로운 메모리에 저장되고 이 메모리와 value2 변수가 연결됩니다. 두 인스턴스의 속성값은 모두 동일하지만 서로 다른 메모리에 저장된 개별 인스턴스입니다.

value2.width = 1.0
value2.height = 2.0

// 이렇게 하면 value2 와 연결된 메모리가 새로운 값으로 업데이트됩니다. 하지만 value 변수와 연결된 메모리는 아무런 변화가 없습니다.

value
value2

// 값 형식은 항상 stack 에 저장됩니다. 그리고 값을 전달할 때마다 새로운 복사본이 생성됩니다.

class SizeObject {
    var width = 0.0
    var height = 0.0
}

var object = SizeObject()

// 인스턴스를 생성하면 stack 과 heap 에 새로운 메모리 공간이 생성됩니다. heap 에는 인스턴스가 저장되고 stack 에는 heap 메모리 주소가 저장됩니다. 그리고 object 변수는 stack 에 저장된 메모리와 연결됩니다. 값 형식과 달리 인스턴스에 바로 접근할 수 없고 항상 stack 을 거쳐서 접근합니다.

var object2 = object

// 이렇게 하면 stack 에 새로운 메모리 공간이 생성되고 여기에는 바로 전에 stack 에 저장했던 주소가 저장됩니다. heap 에서는 새로운 메모리 공간이 생성되거나 인스턴스가 복사되지는 않습니다. 어떤 변수를 통해서 접근하더라도 결과적으로 heap 에 있는 동일한 인스턴스에 접근하게 됩니다.

object2.width = 1.0
object2.height = 2.0

// object2 변수를 통해 변경하고 있지만 object 변수를 통해 변경한 것과 동일합니다. 두 변수가 최종적으로 동일한 인스턴스에 접근하기 때문입니다.

object
object2

// 참조 형식은 heap 에 인스턴스를 저장하고 stack 에 메모리 주소를 저장합니다. 값을 전달할 때마다 인스턴스 복사본이 생성되지는 않습니다. 대신 stack 에 저장되어 있는 주소가 복사됩니다.
// "참조를 전달한다" 는 표현과 "참조를 복사한다" 는 표현에서 참조는 stack 에 저장되어 있는 메모리 주소를 의미합니다. 동일한 인스턴스에 접근하는 메모리 주소가 복사되기 때문에 주소를 여러 번 복사해도 접근 대상이 달라지는 것은 아닙니다. 그래서 어떤 변수를 통해 속성을 바꾸더라도 동일한 인스턴스의 속성을 바꾸게 됩니다.

let v = SizeValue()

// 값 형식의 인스턴스를 상수에 저장하면 모든 속성이 상수가 됩니다. 그래서 속성을 변경하는 코드를 작성하면 속성을 바꿀 수 없다는 에러가 발생합니다. let 키워드는 상수가 가리키는 stack 을 값을 바꾸지 못하는 공간으로 만들어버립니다. 그래서 속성이 변수로 선언되어 있지만 메모리에 저장된 값을 바꿀 수 없기 때문에 속성에 저장된 값을 바꾸는 것은 불가능합니다.

let o = SizeObject()
o.width = 1.0
o.height = 2.0

// 이번에도 let 키워드는 상수가 가리키는 stack 을 값을 바꿀 수 없도록 제한합니다. 참조 형식에서 stack 에는 메모리 주소가 저장되어 있습니다. 여기에 저장되어 있는 메모리 주소를 바꿀 수 없기 때문에 상수가 가리키는 인스턴스를 바꿀 수 없습니다. 반면 인스턴스가 저장되어 있는 heap 은 아무런 제한이 없습니다. 그래서 값 형식과 달리 인스턴스 속성을 마음대로 바꿀 수 있습니다.

// 마지막으로 비교 연산자와 항등 연산자를 메모리 관점에서 살펴보겠습니다. 비교 연산자(== or !=)는 값 형식을 비교할 때 stack 에 저장된 값을 비교합니다. 반면 참조 형식을 비교할 때는 heap 에 저장된 값을 비교합니다. 다시 말해서 형식에 관계 없이 항상 실제 값을 비교합니다. 참조 형식에서 stack 에 저장된 주소를 비교할 때는 항등 연산자(=== or !==)를 사용합니다. 
